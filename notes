%All of this information if either quoted or rephrased in a way that I understand from the book or it's examples
%The goal of this files is to give me a quick reference to many different topics in erlang

Processes and message passing
Module, function, List of arguments - for spawn function spawn(Module, function, args)
From, Message - Client gets the pid the message is from, list_dir is the message - when receiving messages from other processes
Pid ! Msg - Send message to the Pid - self() argument identifies the process sending the message


Lists
lists:map(F,L) - function that returns a list made by applying the fun F to every element of list L
lists:filter(P, L) - function that returns a new list of all that elements E in L such that P(E) is true
List comprehension - [F(X) || X <- L]  ex. [2*X || X<- L]. %Double each element of the list
List subtraction operator - X -- Y, Subtracts elements in Y from X
List append operator - X ++ Y, Appends two lists together

Guards
Guards are used in function headers by using the when keyword
    ex. max(X,Y) when X > Y -> X;
        max(X,Y) -> Y.
A guard is a series of guard expressions seperated by commas, GuardExp1,GuardExp2,GuardExp3...
    True if all the guard expressions evaluate to true
Guard sequences are single guards or a series of guards seperated by semicolons G1;G2;G3...
    True if at least one of the guards evaluates to true
Guards can't call user defined functions
The true (atom) guard can be used as a catchall at the end of an if expression
    if
        Guard -> Expressions;
        Guard -> Expressions;
        Guard -> Expressions;
        ...
        true -> Expressions
    end

Case
ex.
case Expression of
    Pattern1 [when Guard1] -> Expression_sequence1;
    Pattern2 [when Guard2] -> Expression_sequence1;
    ...
end

if
ex.
if
    Guard1 ->
        Expression_sequence1;
    Guard2 ->
        Expression_sequence2;
    ...
end
Can use the true atom as a catchall as the last guard otherwise an exception will be thrown if no Guard is matched
    If an exception is desired then you would want to omit it

Building Lists in Natural Order
1. Always add elements to a list head
2. Taking the elements from the head of an inputlist and adding them head first to an output list results in having the inputlist reversed
3. Use lists:reverse/1 if you need it in the right order
ex.
my_function([H|T], Acc) ->
    my_function(T, H|Acc);
my_function([], Acc) ->
    Acc.

List ++ [H] is very inefficient and only acceptable for short lists

Using the shell
Example of defining a function
    Even = fun(X) -> (X rem 2) =:= 0 end.
Record declarations can't be used in the shell - use rr to read definitions into the shell ex. rr("records.hrl").

Records are tuples in disguise- same storage and preformance
Records allow us to associate names with elements of tuples but you only have a fixed number of elements with non-changing names
Use them if storage is an issue and you can represent your data using a fixed number of atoms
Record declaration ex.
    -record(Name, {
                    key1 = Default1, %keys must be atoms, defaults will be taken if nothing is assigned when created
                    key2 = Default2,
                    key3, %This is like key3 = undefined
                    ...
                  })
Record definitions can be stored in erlang source code files (.erl) or put in files with the extension .hrl which you include in .erl files
    This is similar to .h files in C. It is the only wya to ensure that several Erlang modules use the same record definitions
Somerecord = #recordname{key1=Val1, key2=Val2,...}. %Create new record
NewRecord = Somerecord#recordname{keyN = ValN}. %Copy Somerecord into NewRecord and change keyN val
Extract values - NewRecord#recordname.keyN. %would get the values from that key

Maps - more flexible than records but slower
Can add new names dynamically
Used to represent key-value data structures
Good to use with JSON
Elements are ordered by the keys
Updating a map where the keys are not changed is a space-efficient operation
Looking up the value of a key in a map is an efficient operation
Key-Value serperator is either => or :=
Create new map
#{Key1 Op Val1, Key2 Op Val2, ...., KeyN Op ValN}
Update map based on existing map
NewMap = OldMap#{K1 Op Val1,...}
K=>V is used to update the value of an existing key K with a new value V or to add a completely new K-V pair to the map. It always succeeds
K:=V is used to update the value of an existing key with a new value V. This fails if the map being updated does not contain the new key K
The best way to use them is to use K=>V the first time a key is defined and use Key:=Val each time the value of a specific key is changed
List of BIFs for maps - Page 82,83

try...catch
ex.
    try FuncOfExpressionSeq of
        Pattern1 [when Guard1] -> Expressions1;
        Pattern2 [when Guard2] -> Expressions2;
        ...
    catch
        ExceptionType1: ExPattern1 [when ExGuard1] -> ExExpressions1;
        ExceptionType2: ExPattern2 [when ExGuard2] -> ExExpressions2;
        ...
    after
        AfterExpressions
    end
ExceptionType is an atom (throw, exit, or error) that tells us how the exception was generated - default is throw if none are specified
After is to clean up anything done by FuncOfExpressionSeq
The after section is not required
Ex. catch every possible exception
    try Expr
    catch
        _:_ -> ...  %matches anything
    end
When reading stacktraces the form is {Module, Function, Arity, Info}
